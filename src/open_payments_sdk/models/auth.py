from enum import Enum
from typing import List, Optional, Union

from pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel, conint


class TypeIncoming(Enum):
    incoming_payment = 'incoming-payment'


class ActionIncoming(Enum):
    create = 'create'
    complete = 'complete'
    read = 'read'
    read_all = 'read-all'
    list = 'list'
    list_all = 'list-all'


class AccessIncoming(BaseModel):
    type: TypeIncoming = Field(
        ...,
        description='The type of resource request as a string.  This field defines which other fields are allowed in the request object.',
    )
    actions: List[ActionIncoming] = Field(
        ...,
        description='The types of actions the client instance will take at the RS as an array of strings.',
    )
    identifier: Optional[AnyUrl] = Field(
        None,
        description='A string identifier indicating a specific resource at the RS.',
    )


class TypeOutgoing(Enum):
    outgoing_payment = 'outgoing-payment'


class ActionOutgoing(Enum):
    create = 'create'
    read = 'read'
    read_all = 'read-all'
    list = 'list'
    list_all = 'list-all'


class TypeQuote(Enum):
    quote = 'quote'


class ActionQuote(Enum):
    create = 'create'
    read = 'read'
    read_all = 'read-all'


class AccessQuote(BaseModel):
    type: TypeQuote = Field(
        ...,
        description='The type of resource request as a string.  This field defines which other fields are allowed in the request object.',
    )
    actions: List[ActionQuote] = Field(
        ...,
        description='The types of actions the client instance will take at the RS as an array of strings.',
    )


class Client(RootModel[str]):
    root: str = Field(
        ...,
        description='Wallet address of the client instance that is making this request.\n\nWhen sending a non-continuation request to the AS, the client instance MUST identify itself by including the client field of the request and by signing the request.\n\nA JSON Web Key Set document, including the public key that the client instance will use to protect this request and any continuation requests at the AS and any user-facing information about the client instance used in interactions, MUST be available at the wallet address + `/jwks.json` url.\n\nIf sending a grant initiation request that requires RO interaction, the wallet address MUST serve necessary client display information.',
        title='client',
    )


class AccessToken1(BaseModel):
    value: str


class Continue(BaseModel):
    access_token: AccessToken1 = Field(
        ...,
        description='A unique access token for continuing the request, called the "continuation access token".',
    )
    uri: AnyUrl = Field(
        ...,
        description='The URI at which the client instance can make continuation requests.',
    )
    wait: Optional[int] = Field(
        None,
        description='The amount of time in integer seconds the client instance MUST wait after receiving this request continuation response and calling the continuation URI.',
    )


class StartEnum(Enum):
    redirect = 'redirect'


class Method(Enum):
    redirect = 'redirect'


class Finish(BaseModel):
    method: Method = Field(
        ...,
        description='The callback method that the AS will use to contact the client instance.',
    )
    uri: AnyUrl = Field(
        ...,
        description='Indicates the URI that the AS will either send the RO to after interaction or send an HTTP POST request.',
    )
    nonce: str = Field(
        ...,
        description='Unique value to be used in the calculation of the "hash" query parameter sent to the callback URI, must be sufficiently random to be unguessable by an attacker.  MUST be generated by the client instance as a unique value for this request.',
    )


class InteractRequest(BaseModel):
    start: List[StartEnum] = Field(
        ..., description='Indicates how the client instance can start an interaction.'
    )
    finish: Optional[Finish] = Field(
        None,
        description='Indicates how the client instance can receive an indication that interaction has finished at the AS.',
    )


class InteractResponse(BaseModel):
    redirect: AnyUrl = Field(..., description='The URI to direct the end user to.')
    finish: str = Field(..., description='Unique key to secure the callback.')


class Interval(RootModel[str]):
    root: str = Field(
        ...,
        description='[ISO8601 repeating interval](https://en.wikipedia.org/wiki/ISO_8601#Repeating_intervals)',
        examples=[
            'R11/2022-08-24T14:15:22Z/P1M',
            'R/2017-03-01T13:00:00Z/2018-05-11T15:30:00Z',
            'R-1/P1Y2M10DT2H30M/2022-05-11T15:30:00Z',
        ],
        title='Interval',
    )


class Receiver(RootModel[AnyUrl]):
    root: AnyUrl = Field(
        ...,
        description='The URL of the incoming payment that is being paid.',
        examples=[
            'https://ilp.interledger-test.dev/incoming-payments/08394f02-7b7b-45e2-b645-51d04e7c330c',
            'http://ilp.interledger-test.dev/incoming-payments/08394f02-7b7b-45e2-b645-51d04e7c330c',
            'https://ilp.interledger-test.dev/incoming-payments/1',
        ],
        title='Receiver',
    )


class AssetCode(RootModel[str]):
    root: str = Field(
        ...,
        description='The assetCode is a code that indicates the underlying asset. This SHOULD be an ISO4217 currency code.',
        title='Asset code',
    )


class AssetScale(RootModel[conint(ge=0, le=255)]):
    root: conint(ge=0, le=255) = Field(
        ...,
        description='The scale of amounts denoted in the corresponding asset code.',
        title='Asset scale',
    )


class WalletAddress(RootModel[AnyUrl]):
    root: AnyUrl = Field(
        ...,
        description='URL of a wallet address hosted by a Rafiki instance.',
        title='Wallet Address',
    )


class Amount(BaseModel):
    value: str = Field(
        ...,
        description='The value is an unsigned 64-bit integer amount, represented as a string.',
    )
    assetCode: AssetCode
    assetScale: AssetScale


class LimitsOutgoing1(BaseModel):
    receiver: Optional[Receiver] = None
    debitAmount: Optional[Amount] = Field(
        None,
        description='All amounts are maxima, i.e. multiple payments can be created under a grant as long as the total amounts of these payments do not exceed the maximum amount per interval as specified in the grant.',
    )
    receiveAmount: Optional[Amount] = Field(
        None,
        description='All amounts are maxima, i.e. multiple payments can be created under a grant as long as the total amounts of these payments do not exceed the maximum amount per interval as specified in the grant.',
    )
    interval: Optional[Interval] = None


class LimitsOutgoing2(BaseModel):
    receiver: Optional[Receiver] = None
    debitAmount: Amount = Field(
        ...,
        description='All amounts are maxima, i.e. multiple payments can be created under a grant as long as the total amounts of these payments do not exceed the maximum amount per interval as specified in the grant.',
    )
    receiveAmount: Optional[Amount] = Field(
        None,
        description='All amounts are maxima, i.e. multiple payments can be created under a grant as long as the total amounts of these payments do not exceed the maximum amount per interval as specified in the grant.',
    )
    interval: Optional[Interval] = None


class LimitsOutgoing3(BaseModel):
    receiver: Optional[Receiver] = None
    debitAmount: Optional[Amount] = Field(
        None,
        description='All amounts are maxima, i.e. multiple payments can be created under a grant as long as the total amounts of these payments do not exceed the maximum amount per interval as specified in the grant.',
    )
    receiveAmount: Amount = Field(
        ...,
        description='All amounts are maxima, i.e. multiple payments can be created under a grant as long as the total amounts of these payments do not exceed the maximum amount per interval as specified in the grant.',
    )
    interval: Optional[Interval] = None


class LimitsOutgoing(
    RootModel[Union[LimitsOutgoing1, LimitsOutgoing2, LimitsOutgoing3]]
):
    root: Union[LimitsOutgoing1, LimitsOutgoing2, LimitsOutgoing3] = Field(
        ...,
        description='Open Payments specific property that defines the limits under which outgoing payments can be created.',
        title='limits-outgoing',
    )


class AccessOutgoing(BaseModel):
    type: TypeOutgoing = Field(
        ...,
        description='The type of resource request as a string.  This field defines which other fields are allowed in the request object.',
    )
    actions: List[ActionOutgoing] = Field(
        ...,
        description='The types of actions the client instance will take at the RS as an array of strings.',
    )
    identifier: AnyUrl = Field(
        ..., description='A string identifier indicating a specific resource at the RS.'
    )
    limits: Optional[LimitsOutgoing] = None


class AccessItem(RootModel[Union[AccessIncoming, AccessOutgoing, AccessQuote]]):
    root: Union[AccessIncoming, AccessOutgoing, AccessQuote] = Field(
        ...,
        description='The access associated with the access token is described using objects that each contain multiple dimensions of access.',
    )


class Access(RootModel[List[AccessItem]]):
    root: List[AccessItem] = Field(
        ...,
        description='A description of the rights associated with this access token.',
        max_length=3,
    )


class AccessToken(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    value: str = Field(
        ...,
        description='The value of the access token as a string.  The value is opaque to the client instance.  The value SHOULD be limited to ASCII characters to facilitate transmission over HTTP headers within other protocols without requiring additional encoding.',
    )
    manage: AnyUrl = Field(
        ...,
        description='The management URI for this access token. This URI MUST NOT include the access token value and SHOULD be different for each access token issued in a request.',
    )
    expires_in: Optional[int] = Field(
        None,
        description='The number of seconds in which the access will expire.  The client instance MUST NOT use the access token past this time.  An RS MUST NOT accept an access token past this time.',
    )
    access: Access
